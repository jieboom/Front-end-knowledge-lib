#### 内存管理
**简介**
像C语言这种底层语言都会有可操控的内存管理系统,像暴露出来的api (malloc 和 free)分别代表分配和释放内存.但是像JS这类高级语言,变量定义时会自动分配内存,以及在不使用的时候自动释放他们,自动释放的过程称为垃圾回收.
**内存的生命周期**
1. 分配变量所需要的内存空间
2. 使用分配的内存(读/写)
3. 不需要的时候释放它们

**如何进行垃圾回收**
*如何找到恰当的时机去释放内存*
1. 引用
垃圾回收算法主要依赖于引用. 引用所指就是一个对象有权限访问另外一个对象(隐式或显式),这成为一个对象引用另外一个对象.隐式通常指的是对原型链的引用,而显式指的是对属性的引用.
注: 引用不仅仅存在于js对象,还存在词法作用域的引用.

2. 算法1: 引用计数垃圾收集
算法的思路是把"内存不在需要"简单定义为对象不被其他对象引用,如果对象的引用为0,则对象会被垃圾机制回收.
引用计数的缺点:**循环引用**
    ```
    function name() {
        const a ={b:{}}
        const b = {a:{}}
        a.b = b
        b.a = a
    }
    ```
函数执行结束后, 分配内存的引用计数不为0;
函数结束当前作用域(上下文)的变量置为null,解除对原有分配内存的引用,但是由于循环引用的存在,内存的引用数不是0,故无法被垃圾收集.造成内存泄漏,也就是无法被回收的问题.
2. 算法2: 标记-清除算法
算法的思路是把"内存不在需要"简化定义为"对象不可获得".
算法有一个叫根"root"的对象,JavaScript里称为全局对象,然后.垃圾回收器会定期去访问根的所引用的对象,然后再找根属性所引用的对象,用相同方式访问根的属性,类似于树的遍历,找到所有可以访问到的对象和不可访问的对象,然后回收不可访问的对象.
这种算法不存在循环引用的问题,因为循环引用的对象肯定是不可获得的.
也就是说 不可获得对象包含循环引用和0引用对象.